# -*- coding: utf-8 -*-
"""Real Esate Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U-wIH1BGlkpVCTwtmKWKHkRbZzA0AWVo
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import pandas as pd
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Activation
from tensorflow.keras.optimizers import Adam

from keras.layers.core import Dense
from keras.layers import Input
from keras.models import Sequential
from keras import optimizers
from sklearn.model_selection import train_test_split

from google.colab import files
uploaded = files.upload()
import io
Data = pd.read_csv(io.BytesIO(uploaded['Real estate valuation data set (1).csv']))
Data.head(7).T
Data = Data.drop('Unnamed: 8',axis=1)
Data = Data.drop('Unnamed: 9',axis=1)
Data = Data.drop('Unnamed: 10',axis=1)
Data = Data.drop('Unnamed: 11',axis=1)
Data = Data.drop('Unnamed: 12',axis=1)
Data = Data.drop('No',axis=1)
Data.info()
Data.describe().transpose()
X = Data.drop('Y house price of unit area',axis =1).values
y = Data['Y house price of unit area'].values
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=101)
from sklearn.preprocessing import StandardScaler
s_scaler = StandardScaler()
X_train1 = s_scaler.fit_transform(X_train.astype(np.float))
X_test = s_scaler.transform(X_test.astype(np.float))
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Activation
from tensorflow.keras.optimizers import Adam
model = Sequential()
model.add(Dense(5,activation='relu'))
model.add(Dense(5,activation='relu'))
model.add(Dense(5,activation='relu'))
model.add(Dense(5,activation='relu'))
model.add(Dense(1))
model.compile(optimizer='Adam',loss='mse')
model.fit(x=X_train1,y=y_train,
          validation_data=(X_test,y_test),
          batch_size=128,epochs=1000)
model.summary()

loss_df = pd.DataFrame(model.history.history)
loss_df.plot(figsize=(12,8))

y_pred = model.predict(X_test)
y_pred_train = model.predict(X_train1)
from sklearn import metrics
print('MAE:', metrics.mean_absolute_error(y_test, y_pred))  
print('MSE:', metrics.mean_squared_error(y_test, y_pred))  
print('RMSE:', np.sqrt(metrics.mean_squared_error(y_test, y_pred)))
print('VarScore:',metrics.explained_variance_score(y_test,y_pred))
fig = plt.figure(figsize=(10,5))
plt.scatter(y_test,y_pred, color = "red")
plt.scatter(y_train,y_pred_train, color ='blue')
plt.title("Predicted Vs Actual Prices")
plt.ylabel("Predicted Value")
plt.xlabel("Actual Value")
plt.plot(y_test,y_test,'r', color = "green")

k = y_pred.reshape((83,1))
pred_output=np.concatenate((k,y_pred_train))

real_output=np.concatenate((y_test,y_train))
print(real_output)

from sklearn.linear_model import LinearRegression
regressor = LinearRegression()  
regressor.fit(X_train1, y_train)
print(regressor.intercept_)
print(regressor.coef_)
y_pred = regressor.predict(X_test)
coeff_df = pd.DataFrame(regressor.coef_, Data.drop('Y house price of unit area',axis =1).columns, columns=['Coefficient']) 
coeff_df

from scipy import stats
z = pred_output.reshape(414,)
slope, intercept, r_value, p_value, std_err = stats.linregress(y_test, y_pred)

line = slope*y_test+intercept
plt.plot(y_test, line, 'r', label='y={:.2f}x+{:.2f}'.format(slope,intercept))
#end

plt.legend(fontsize=9)
plt.scatter(y_test, y_pred)

plt.show()

print(pred_output)